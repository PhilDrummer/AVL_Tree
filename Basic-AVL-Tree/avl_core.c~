/* Basic AVL-Tree implementation - Core module */
/*
 * Author: Philipp Schaad
 * Creation Date: 011015 
 */

#include "avl_core.h"

// Temp.
int main(){
  return 0;
}

/*
 * Function: key_insert
 * --------------------
 * Description:
 * Create and insert a node directly in to a tree, 
 * according to its order-key. The function has an
 * integer return type for reporting wether or not
 * the insert was successful.
 *
 * Arguments: key - The identification key in the BST.
 *            tree - The corresponding tree.
 *
 * Returns: int 0 - insert failed.
 *              1 - insert was successful.
 *             -1 - fatal error.
 */
int key_insert(int key, AvlTree *tree){
  // 
}

/*
 * Function: has_key
 * -----------------
 * Descripton:
 * Has key checks for a specific key inside a
 * tree, returning 0 if it was not found, and
 * 1 if it was found.
 *
 * Arguments: key - The identification key in the BST.
 *            tree - The corresponding tree.
 *
 * Returns: int 0 - if not found.
 *              1 - if found.
 */
int has_key(int key, AvlTree *tree){
  if(key_lookup(key, tree) == NULL){
    return 0;
  }
  return 1;
}

/*
 * Function: key_lookup
 * --------------------
 * Description: 
 * Key lookup function searches for a specific node
 * in the tree, according to it's direct order-key.
 * 
 * Arguments: key - The identification key in the BST.
 *            tree - The corresponding tree.
 *
 * Returns: Node - The node that was found while searching
 *                 for that key. (May be NULL). [POINTER]!
 */
Node * key_lookup(int key, AvlTree *tree){
  // Check if the tree exists, abort if not.
  if(tree == NULL){
    return NULL;
  }
  
  // Points to the active node in the tree iteration.
  Node *active = tree->root;

  // Iterate over the tree, halting if the end is
  // reached or the node is found.
  while(true){

    // Compare the key to the active node.
    if(key < active->key){

      // Case 1, key is to the left of active.
      if(active->left_child == NULL){
	// Key not in tree.
	return NULL;
      }else{
	// Continue iteration. (to left of active)
	active = active->left_child;
      }
      
    }else if(key > active->key){

      // Case 2, key is to the right of active.
      if(active->right_child == NULL){
	// Key not found in tree.
	return NULL;
      }else{
	// Continue iteration. (to the right of active)
	active = active->right_child;
      }
      
    }else{
      // Case 3, key is equal to active -> key found!
      return active;
    }
  }

  // Safety fall-thru return.
  return NULL;
}

/*
 * Functoin: get_height
 * --------------------
 * Description:
 * Returns the current total height of the tree.
 *
 * Arguments: tree - Pointer to the corresponding tree.
 *
 * Returns: int - height of the tree.
 *          -1 in case of failure. (tree does not exist.)
 */
int get_height(AvlTree *tree){
  if(tree == NULL){
    return -1;
  }
  return tree->height;
}

/*
 * Function: holds
 * ---------------
 * Description:
 * Returns the number of nodes in a tree.
 *
 * Arguments: tree - Pointer to the corresponding tree.
 *
 * Returns: int - the number of nodes in the tree.
 *          -1 in case of failure. (tree does not exist.)
 */
int holds(AvlTree *tree){
  if(tree == NULL){
    return -1;
  }
  return tree->n_nodes;
}

/*
 * Function: traverse_inorder_console
 * ----------------------------------
 * Description:
 * This function does a (recursive) inorder traversal
 * of the AVL-Tree. The ouput is console-based, being
 * displayed as a one-line string.
 * 
 * Arguments: node - The node the recursion is at.
 * 
 * Returns: void
 */
void traverse_inorder_console(Node *node){
  if(node != NULL){
    traverse_inorder_console(node->left_child);
    printf("%d ", node->key);
    traverse_inorder_console(node->right_child);
  }
}
